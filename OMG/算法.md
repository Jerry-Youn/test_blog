### 「算法复杂度」

- 什么是复杂度？

  - 程序执行时需要的**计算量**和**内存空间**（和代码是否简介无关）

  - 复杂度是**数量级**（方便记忆、推广），不是具体的数字

  - 一般针对一个具体的算法，而非一个完整的系统

    

- 时间复杂度 - 考察程序执行时需要的计算量

  - ![image-20220411180012451](算法.assets/image-20220411180012451-0621712.png)

  - 程序执行时需要的计算量（cpu）

    > O(1)：计算量和输入量无关，一次就够（数量级）
    >
    > O(n)：计算量和传输的数据量一样（数量级）
    >
    > O(n^2)：计算量是输入量的平方（数据量）
    >
    > O(logn)：输入量越多，计算量越平稳。
    >
    > O(nlogn)：输入量越多，计算量越大

  - 代码演示

    ```js
    //O(1)
    function fn(obj = {}){
      return obj.a + obj.b + obj.c
    }
    
    //O(n)
    function fn(arr = []){
      for(let j =0; j<arr.length; j++){
        console.info(arr[j])
      }
    }
    
    //O(n^2)
    function fn(arr = []){
      for(let j =0; j<arr.length; j++){
        for(let i =0; i<arr.length; i++){
          console.info(arr[i])
        }
      }
    }
    
    //O(logn)--二分法和递归
    略
    
    //O(nlogn)----一次循环+一次二分
    ```

    

- 空间复杂度 - 考察程序执行时需要的内存空间

  - 程序执行时需要的内存空间

    > O(1)：有限的、可数的空间（数量级）
    > 
    > O(n)：和输入的数据量相同的空间（数量级）
    > 
    > O(n^2)：
    > 
    > O(logn)：
    > 
    > O(nlogn)：
    
    

  - 代码演示

    ```js
    //O(1)
    function fn(arr = []){
      const a = arr[1]
      const b = arr[2]
    }
    
    //O(n)
    function fn(arr = []){
      const arr2 = []
      for(let i =0; i<arr.length; i++){
          arr2[i] = arr[i] + 10 
        }
    }
    ```
    
    

































